char					*complete;
int						tab_level;

/*
** @flag = 'b' - binary
**		= 'i' - incorrect_sequence, tab leaves
**		= 'a' - auto-completion, immediate
*/

static char			sign_means(char c, char flag)
{
	if (c == 0)
		return (0);
	else if (flag == 'b')
	{
		if (c == '#' || c == '%' || c == '!' || c == '@' || c == '"'
			|| c == '\\' || c == '^' || c == '*' || c == '(' || c == ')'
			|| c == '[' || c == ']' || c == '{' || c == '}' || c == ':'
			|| c == '=' || c == '/' || c == ',' || c == '\'' || c == '-')
			return (1);
	}
	else if (flag == 'i')
	{
		if (c == '#' || c == '@' || c == '^' || c == '=' || c == ':'
			|| c == '-' || c == ',' || c == '?' || c == '%')
			return (1);
	}
	else if (flag == 'a')
	{
		if (c == '\\' || c == '!')
			return (1);
	}
	else
	{
		if (c == ';' || c == '&' || c == '|' || c == ' ')
			return (1);
	}
	return (0);
}

// static char			*return_pool(int *pool, size_t i, size_t j, size_t k)
// {
// 	if ((k == 0 || g_rline.cmd[k] == ';' || g_rline.cmd[k] == '&'
// 		|| g_rline.cmd[k] == '|') && j == i)
// 	{
// 		*pool = 4;
// 		return (NULL);
// 	}
// 	if ((k == 0 || g_rline.cmd[k] == ';' || g_rline.cmd[k] == '&'
// 		|| g_rline.cmd[k] == '|') && j > i && sign_means(g_rline.cmd[i], 'c'))
// 		*pool = 1;
// 	else if (g_rline.cmd[i] == '$')
// 		*pool = 2;
// 	else if (ft_isalnum(g_rline.cmd[i]) || g_rline.cmd[i] == '.')
// 		*pool = 3;
// 	else
// 	{
// 		// printf("k = %zu, i = %zu, j = %zu\n", k, i, j);
// 		*pool = 0;
// 	}
// 	return (ft_strndup(g_rline.cmd + i, j - i));
// }

/*
** If the word starts with alphabetic and numeric values or is NULL -
** it is considered as a file or binary name
** If there are "#%@(by us)^=:-,?" signs -
** completion is not done
** if there are "!\" signs, they become "\!" and "\\"
** If there are "* or slash" - we look in the arguments pool
** 
*/

//восклицательный знак становится \!, как и '\',
//звездочка и бэкслеш сразу переключает на аргументы
//не ищутся при: #, %, @ (у нас),^, =, :, -, ',', ?
//ищутся со знаками, точка
//ищутся, не влияют знаки (они убираются): {}, [], (), "", ''

static int			analyse_quote_args(char fi)
{
	if (fi == '*' || fi == '/' || (complete &&
		(complete[0] == '*' || complete[0] == '/')))
		return (3);
	else if ((fi == '.' && !complete) ||
		(complete && complete[0] == '.' && !complete[1]))
	{
		char_add('/');
		return (0);
	}
	else if ((fi == '.' && complete) ||
		(complete && complete[0] == '.' && complete[1]))
		return (1);
	return (5);
}

static int			analyse_complete(void)
{
	char			fi;

	if (g_rline.pos == 0)
		return (4);
	fi = (g_rline.pos > 0) ? g_rline.cmd[g_rline.pos - 1] : 0;
	if (complete && ft_isalnum(complete[0]))
		return (5);
	if (sign_means(fi, 'i') || (complete && sign_means(complete[0], 'i')))
		return (-1);
	if ((sign_means(fi, 'a') && !complete) ||
		(complete && sign_means(complete[0], 'a') && !complete[1]))
	{
		backspace_process();
		char_add('\\');
		(fi == '!' || (complete && complete[0] == '!'))
			? char_add('!') : char_add('\\');
		return (0);
	}
	else if ((sign_means(fi, 'a') && complete) ||
		(complete && sign_means(complete[0], 'a') && complete[1]))
		return (-1);
	if (fi == '$' || (complete && complete[0] == '$'))
		return (2);
	return (analyse_quote_args(fi));
}

/*
** Here we get array depending on the @pool: binary, alphabet, arguments or
** variables
** A routing function
*/

static char			**get_menu(char pool, t_completion *menu_buf)
{
	char			**menu;

	menu = (char**)ft_xmalloc((sizeof(char*) * (10 + 1))); // if (pool == 'c')
	menu[10] = 0;
	menu[0] = "la";
	menu[1] = "ls";
	menu[2] = "lp";
	menu[3] = "lo";
	menu[4] = "llll";
	menu[5] = "lk";
	menu[6] = "ly";
	menu[7] = "lg";
	menu[8] = "lw";
	menu[9] = "lh";
	menu_buf->word_len = 8;
	menu_buf->word_nb = 10;
	// {
	// 	menu = "Please, choose a letter.\nThere are too many binaries:\n"; //придумать, как возвращать алфавит
	// }
	return (menu);
}

i = 0;
		// printf("\n%zu\n", total);
		// while (i < total)
		// {
		// 	printf("%s\n", menu[i]);
		// 	i++;
		// }
		//free_vec(menu);

/*
** If the @g_complete line is empty and @pool is 1, menu consists of all
** the binary-options found in the environmental variable PATH and
** in the internal list of builtin programs.
** If @g_complete is not empty and @pool is 1 - the function
** ft_path_pars returns only those options that match.
** The same principle for other pools.
*/

/*
** @pool = pool of variables: binary-files (1), variables (2),
** arguments (3), bell (nothing can be done - 0);
** @total = total number of options
** @max_len = maximal length of the option-string within the whole
** menu array - is needed for the buffer output part
** @tech_line = is needed for analysis of the g_complete string - 
** parsing of the g_complete string
** @delete = by each TAB a word-option is added to the 
** g_complete part. If this option does not taken by the user and
** the user pushes TAB to change the option - the old option should
** be deleted - as many symbols as in @delete variable
** If there are no options to be auto-completed, there is a bell.
*/

/*
** After printing some kind of big menu (the number of lines is bigger
** than the space left in the terminal) the behavior is as in bash - 
** printing new prompt and the line without any changes
*/

/*
** After any key except of TAB is pushed, the menu under the line
** is cleared
*/

Сделать:
Вставить ft_select на определенную комбинацию:
1) Заходим по табу - под курсором пусто или пробел
Если ничего не находим - белл
2) проверяем то, что стоит впереди - находим слеши на слове, на котором стоим - это абсолютный или относительный путь
3) записываем все по папке в двумерный массив
4) по alt + / переходим в функцию анализа и сохранения, которая возвращает двумерный маccив
5) для ft_select кидаем все в строку через пробелы
6) удаляем массив двумерный
Автодополнение

$HISTSIZE - можно изменить размер запоминаемой истории

/*
** Here we take everything that is before the cursor in the string
** and analyse it after
*/

char				*fill_complete(size_t pos_back) //TODO if it is needed
{
	size_t			beg_word;
	size_t			end_word;
	size_t			space;
	char			*tmp;
	char			*complete;

	beg_word = g_rline.pos;
	end_word = beg_word;
	if (!ft_isalnum(g_rline.cmd[beg_word]) && beg_word > 0
		&& ft_isalnum(g_rline.cmd[beg_word - 1]))
		beg_word--;
	while (beg_word > 0 && ft_isalnum(g_rline.cmd[beg_word]))
		beg_word--;
	while (g_rline.cmd[end_word] && end_word < g_rline.pos
		&& ft_isalnum(g_rline.cmd[end_word]))
		end_word++;
	space = beg_word;
	while (space > 0 && g_rline.cmd[space] == ' ')
		space--;
	tmp = ft_strndup(g_rline.cmd + beg_word, end_word - beg_word);
	complete = ft_strtrim(tmp);
	free(tmp);
	return (complete);
}

PARSER________________________________________________________________________

i = ft_strchri(g_shvar[5], '=');
	if (g_shvar[5][i + 1] == '0')
	{
		g_buf_cmd = NULL;
		g_len_buf_cmd = 0;
		g_flag = 0;
	}
	g_shvar[5][i + 1] += 1;

Сделать - основной принцип, чтобы заходил заново в ридлайн и выходил из него
В ридлайне поправить кнопки "если" - автодополнение и ctrl-C

ctrl-D из slash выходит из проги, но запускает парсер
ctrl-D из кавыки, сабшелла и тд запускает парсер НЕ выходит

static int		subshell_character(int *flag_subsh)
{
	flag_subsh += 1;
	if (g_len_buf_cmd == 0)
		g_buf_cmd = init_buffer_cmd(g_cmd_size, g_cmd, &g_len_buf_cmd);
	else
		g_buf_cmd = add_buffer_cmd(g_buf_cmd, g_cmd_size, g_cmd, &g_len_buf_cmd);
	clean_parser42();
	g_prompt.prompt_func = subshell_prompt;
	if (interactive_shell())
		exit(PARSER_ERROR); //TODO удалить
	return (0);
}

int				parenthesis_or_brace_subshell(int *flag_subsh)
{
	if (g_techline.line[0] == OPAREN)
		if (check_if_not_closed(OPAREN, CPAREN) == -1)
			subshell_character(flag_subsh);
	if (g_techline.line[0] == OBRACE)
		if (check_if_not_closed(OBRACE, CBRACE) == -1)
			subshell_character(flag_subsh);
	return (0);
}



POSIX
/* Cause all the jobs in the current pipeline to exit. */
void
terminate_current_pipeline ()
{
  if (pipeline_pgrp && pipeline_pgrp != shell_pgrp)
    {
      killpg (pipeline_pgrp, SIGTERM);
      killpg (pipeline_pgrp, SIGCONT);
    }
}

	while (ft_strncmp(g_shvar[i], "HISTFILE=",
		ft_strchri(g_shvar[i], '=') + 1) != 0)
		i++;

//printf("last %s\nfirst %s\nlast = %zu, len = %zu\n", g_hist.hist[g_hist.last - 1],
g_hist.hist[g_hist.start], g_hist.last, g_hist.len);

// static int	print_all_vars(void)
// {
// 	size_t	i;

// 	i = 0;
// 	printf("%.10s\n", "\n\nENVIRON");
// 	while (g_env[i])
// 		printf("%s\n", g_env[i++]);
// 	i = 0;
// 	printf("%.10s\n", "\n\nWORKING");
// 	while (g_shvar[i])
// 		printf("%s\n", g_shvar[i++]);
// 	i = 0;
// 	printf("%.10s\n", "\n\nLOCAL");
// 	while (g_lovar[i])
// 		printf("%s\n", g_lovar[i++]);
// 	return (0);
// }

Сделать: кнопки вверх-вниз и другие по ридлайну, доделать ctrl-up и ctrl-down
Потом fс
Потом !