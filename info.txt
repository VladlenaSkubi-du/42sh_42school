char					*complete;
int						tab_level;

/*
** @flag = 'b' - binary
**		= 'i' - incorrect_sequence, tab leaves
**		= 'a' - auto-completion, immediate
*/

static char			sign_means(char c, char flag)
{
	if (c == 0)
		return (0);
	else if (flag == 'b')
	{
		if (c == '#' || c == '%' || c == '!' || c == '@' || c == '"'
			|| c == '\\' || c == '^' || c == '*' || c == '(' || c == ')'
			|| c == '[' || c == ']' || c == '{' || c == '}' || c == ':'
			|| c == '=' || c == '/' || c == ',' || c == '\'' || c == '-')
			return (1);
	}
	else if (flag == 'i')
	{
		if (c == '#' || c == '@' || c == '^' || c == '=' || c == ':'
			|| c == '-' || c == ',' || c == '?' || c == '%')
			return (1);
	}
	else if (flag == 'a')
	{
		if (c == '\\' || c == '!')
			return (1);
	}
	else
	{
		if (c == ';' || c == '&' || c == '|' || c == ' ')
			return (1);
	}
	return (0);
}

// static char			*return_pool(int *pool, size_t i, size_t j, size_t k)
// {
// 	if ((k == 0 || g_rline.cmd[k] == ';' || g_rline.cmd[k] == '&'
// 		|| g_rline.cmd[k] == '|') && j == i)
// 	{
// 		*pool = 4;
// 		return (NULL);
// 	}
// 	if ((k == 0 || g_rline.cmd[k] == ';' || g_rline.cmd[k] == '&'
// 		|| g_rline.cmd[k] == '|') && j > i && sign_means(g_rline.cmd[i], 'c'))
// 		*pool = 1;
// 	else if (g_rline.cmd[i] == '$')
// 		*pool = 2;
// 	else if (ft_isalnum(g_rline.cmd[i]) || g_rline.cmd[i] == '.')
// 		*pool = 3;
// 	else
// 	{
// 		// printf("k = %zu, i = %zu, j = %zu\n", k, i, j);
// 		*pool = 0;
// 	}
// 	return (ft_strndup(g_rline.cmd + i, j - i));
// }

/*
** If the word starts with alphabetic and numeric values or is NULL -
** it is considered as a file or binary name
** If there are "#%@(by us)^=:-,?" signs -
** completion is not done
** if there are "!\" signs, they become "\!" and "\\"
** If there are "* or slash" - we look in the arguments pool
** 
*/

//восклицательный знак становится \!, как и '\',
//звездочка и бэкслеш сразу переключает на аргументы
//не ищутся при: #, %, @ (у нас),^, =, :, -, ',', ?
//ищутся со знаками, точка
//ищутся, не влияют знаки (они убираются): {}, [], (), "", ''

static int			analyse_quote_args(char fi)
{
	if (fi == '*' || fi == '/' || (complete &&
		(complete[0] == '*' || complete[0] == '/')))
		return (3);
	else if ((fi == '.' && !complete) ||
		(complete && complete[0] == '.' && !complete[1]))
	{
		char_add('/');
		return (0);
	}
	else if ((fi == '.' && complete) ||
		(complete && complete[0] == '.' && complete[1]))
		return (1);
	return (5);
}

static int			analyse_complete(void)
{
	char			fi;

	if (g_rline.pos == 0)
		return (4);
	fi = (g_rline.pos > 0) ? g_rline.cmd[g_rline.pos - 1] : 0;
	if (complete && ft_isalnum(complete[0]))
		return (5);
	if (sign_means(fi, 'i') || (complete && sign_means(complete[0], 'i')))
		return (-1);
	if ((sign_means(fi, 'a') && !complete) ||
		(complete && sign_means(complete[0], 'a') && !complete[1]))
	{
		backspace_process();
		char_add('\\');
		(fi == '!' || (complete && complete[0] == '!'))
			? char_add('!') : char_add('\\');
		return (0);
	}
	else if ((sign_means(fi, 'a') && complete) ||
		(complete && sign_means(complete[0], 'a') && complete[1]))
		return (-1);
	if (fi == '$' || (complete && complete[0] == '$'))
		return (2);
	return (analyse_quote_args(fi));
}

/*
** Here we get array depending on the @pool: binary, alphabet, arguments or
** variables
** A routing function
*/

static char			**get_menu(char pool, t_completion *menu_buf)
{
	char			**menu;

	menu = (char**)ft_xmalloc((sizeof(char*) * (10 + 1))); // if (pool == 'c')
	menu[10] = 0;
	menu[0] = "la";
	menu[1] = "ls";
	menu[2] = "lp";
	menu[3] = "lo";
	menu[4] = "llll";
	menu[5] = "lk";
	menu[6] = "ly";
	menu[7] = "lg";
	menu[8] = "lw";
	menu[9] = "lh";
	menu_buf->word_len = 8;
	menu_buf->word_nb = 10;
	// {
	// 	menu = "Please, choose a letter.\nThere are too many binaries:\n"; //придумать, как возвращать алфавит
	// }
	return (menu);
}

i = 0;
		// printf("\n%zu\n", total);
		// while (i < total)
		// {
		// 	printf("%s\n", menu[i]);
		// 	i++;
		// }
		//free_vec(menu);

Сделать:
Вставить ft_select на определенную комбинацию:
1) Заходим по табу - под курсором пусто или пробел
Если ничего не находим - белл
2) проверяем то, что стоит впереди - находим слеши на слове, на котором стоим - это абсолютный или относительный путь
3) записываем все по папке в двумерный массив
4) по alt + / переходим в функцию анализа и сохранения, которая возвращает двумерный маccив
5) для ft_select кидаем все в строку через пробелы
6) удаляем массив двумерный
Автодополнение

$HISTSIZE - можно изменить размер запоминаемой истории

